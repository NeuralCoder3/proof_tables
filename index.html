<!doctype html><html lang="en"><head><meta charset="utf-8"/><link rel="icon" href="/proof_tables/favicon.ico"/><meta name="viewport" content="width=device-width,initial-scale=1"/><meta name="theme-color" content="#000000"/><meta name="description" content="Play with proof tables"/><link rel="apple-touch-icon" href="/proof_tables/logo192.png"/><link rel="manifest" href="/proof_tables/manifest.json"/><title>Proof Table</title><script defer="defer" src="/proof_tables/static/js/main.443fe5fc.js"></script><link href="/proof_tables/static/css/main.46edb55d.css" rel="stylesheet"></head><body><noscript>You need to enable JavaScript to run this app.</noscript><div id="ide-wrapper" class="toggled" style="display:none"><div id="code-wrapper"><div id="document"><div><textarea id="code1">
Require Import Init.Prelude Unicode.Utf8.
Require Import Lia. 

Goal 3 = 3.
          </textarea></div></div></div></div><script type="module">import { JsCoq, FormatPrettyPrint } from '/proof_tables/jscoq_new/jscoq.js';

    const fpp = new FormatPrettyPrint();
    window.fpp = fpp;
    window.module_finished = new Promise(resolve => window.module_finished_resolve = resolve);
    window.module_finished_loading = false;

    var jscoq_ids = ['code1'];

    window.coqdoc_ids = jscoq_ids;

    var jscoq_opts = {
      prelude: true,
      implicit_libs: true,
      editor: { mode: { 'company-coq': true }, keyMap: 'default' },
      init_pkgs: ['init'],
      all_pkgs: ['coq'],
      debug: false,
      node_modules_path: "/proof_tables/",

      file_dialog: false,
    };

    // see coq-manager goNext
    function addAndExecute(coq, sid, code) {
      // remove comments (* ... *) (can be nested and multiline)
      let code2 = "";
      let i = 0;
      let level = 0;
      while (i < code.length) {
        if (code[i] == '(' && code[i + 1] == '*') {
          level++;
          i += 2;
        } else if (code[i] == '*' && code[i + 1] == ')') {
          level--;
          i += 2;
        } else if (level == 0) {
          code2 += code[i];
          i++;
        } else {
          i++;
        }
      }
      // split into sentences (end with .)
      let sentences = code2.split('.');
      // remove empty sentences
      sentences = sentences.filter(s => s.trim().length > 0);
      sentences = sentences.map(s => s.trim() + '.');
      // add all
      let new_sid = sid;
      for (let i = 0; i < sentences.length; i++) {
        const s = sentences[i];
        coq.add(new_sid, new_sid+1, s);
        new_sid++;
      }
      // execute last
      coq.exec(new_sid);
      // return new sid
      return new_sid;
    }

    async function sleepWait(f) {
      await new Promise(resolve => {
        function run() {
          if(f.isDone()) {
            resolve();
          } else {
            setTimeout(run, 100);
          }
        }
        run();
      });
    }
    
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    const coq = await JsCoq.start(jscoq_ids, jscoq_opts);

      console.log("JsCoq started", coq, coq.when_ready);
      /** @type {CoqManager} */
      window.coq=coq;

        await coq.when_ready;
        console.log("JsCoq ready");
        // console.log(coq);
        // console.log(coq.coq); 

        /** @type {CoqWorker} */
        const worker = coq.coq;
        window.worker = worker;
        
        // worker.observers.push(o);
        // console.log("Worker:",worker);
        // console.log("provider:",coq.provider);
        const stm = {
            coq_sid: 2,
            text: "Require Import Init.Prelude Classical Nat PeanoNat.", // Lia
            flags: {},
            sp: {
              mark: (s,m,l) => {},
              highlight: (s,f) => {}
            }
            // phase, feedback
          };
        await coq.add(
          stm,
          1
        );

        // see coqpending (in manager) -> add, resolve in worker -> future in worker
        // await sleep(2000);
        await new Promise(resolve => {
          function run() {
            if(worker.sids[2].isDone()) {
              console.log("worker ready!");
              resolve();
            } else {
              setTimeout(run, 100);
            }
          }
          run();
          // worker.sids[2].promise.then(resolve);
        });

        // load preload.v file
        const text = await (await fetch("/proof_tables/preload.v")).text();

        const sid = addAndExecute(worker, 2, text);
        window.sid = sid;
        console.log("starting sid:",sid);

        // worker.add(sid, sid+1, "Example E1241241: 3 = 3 -> 4=4 -> 5=5.");
        // worker.exec(sid+1);
        // worker.goals(sid+1);

        // worker.add(sid+1, sid+2, "intro A.");
        // worker.exec(sid+2);
        // worker.goals(sid+2);

        // worker.add(sid+2, sid+3, "intro B.");
        // worker.exec(sid+3);
        // worker.goals(sid+3);

        // // remove element sid+2, sid+3
        // // worker.sids.pop();
        // // worker.sids.pop();
        // // console.log(worker.sids);
        // // console.log(coq.when_ready);
        // console.log("observer promise",o.when_ready);
        // // await o.when_ready;
        // await sleepWait(worker.sids[sid+3]);
        // console.log("observer ready");
        // // worker.cancel(sid+3);
        // worker.cancel(sid+2);

        // worker.add(sid+1, sid+2, "intro C.");
        // worker.exec(sid+2);
        // worker.goals(sid+2);

        // worker.add(sid+2, sid+3, "intro D.");
        // worker.exec(sid+3);
        // worker.goals(sid+3);


        // // worker.add(sid+1, sid+4, "intro C.");
        // // worker.exec(sid+4);
        // // worker.goals(sid+4);

        // // worker.add(sid+4, sid+5, "intro D.");
        // // worker.exec(sid+5);
        // // worker.goals(sid+5);

        window.module_finished_resolve();
        window.module_finished_loading = true;
        console.log("module finished", window.module_finished);</script><div id="root"></div></body></html>